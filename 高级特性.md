

### 一、Junit测试

* #### 测试分类

  1. **黑盒测试**

     不需要写代码，给输入值，看程序是否属于期望值

  2. **白盒测试**

     需要写程序，看程序运行的过程。Junit属于白盒测试。

  *流程*：

* **加  ``` @test ```**
* **添加依赖进lib**
* **Assert 断言来判断结果 **

### 二、反射（框架设计的灵魂）

* 自己开发框架的话一定要对反射机制十分熟悉

 *  框架：半成品软件。可以在框架的基础上进行软件开发，简化编码。

 *  架构师必须掌握。

 *  **定义：反射是指将 类的各个组成部分封装成其他对象，这就是反射机制**

 *  **例如Method对象、constructor对象、Field对象、Class对象等**

       * 好处：1. 在程序的运行过程中操作这些对象。 
                    2.  解耦，增强程序的可拓展性。

* 三种获取Class对象的方式：

  1. Class.forName("全类名")：将字节码文件加载进内存，返回class对象；

  2. 类名.class:  通过类名的属性class获取;

  3. 对象.getClass():get.Class()方法在Object类中定义。

     **同一字节码文件在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取class对象，都是同一个。**

     _____

     

  #### Class对象的功能

     对象.getField( )                                        获取public修饰的成员变量。
  
  ​	对象.getDeclareField()                         获取任何修饰的成员变量。
  
  ​	setAcceissible（true）                           暴力反射，忽略修饰符。
  
  ​	getConstructor() .newInstance()          获取构造方法（用来创建方法）
  
  ---
  
* #### 案例

     * 需求：写一个框架，在不改变该类的任何代码的前提下，可以帮我们创建任意累的对象。
     * 实现：
       1. ​         配置文件
       2. ​            反射
     * 步骤：
                   1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中。
                      2. 在程序中加载读取配置文件。
                      3. 使用反射技术来加载类文件进内存。
                      4. 创建对象
                      5. 执行方法

---

### 三、注解

作用：用来说明程序，让计算机理解。

例如：@Override    @Test    

* 作用分类：
  	1. 编写文档：通过代码里标识的注解生成文档（生成doc 文档）
   	2. 代码分析：通过代码里表示的注解对代码进行分析（使用反射）
   	3. 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查（Override） 

* **jdk预定义注解**

1. @Override：检测方法是否是继承自父类（接口）
2. @Deprecated：该注解标注的内容，表示已过时
3. @Suppresswarnings：压制警告

* **自定义注解**
  1. @interface +注解名称{}
  2. 本质：注解本质上是一个接口，该接口继承Annotation
          * public @interface
  3. 属性：接口中的抽象方法
     * 返回值类型：基本数据类型，String，枚举，注解，以上类型的数组
     * 使用时需要给属性赋值
     * 使用default关键字修饰的方法可以不进行赋值。
     * 如果只有一个属性需要注释，并且属性的名称是value，则可以省略。
     * **数组赋值使用{ }**
  4. 元注解：**描述注解的注解**。
     * @Target：描述注解能够作用的文职
     * @Rentention：描述注解被保留的位置   **当前被描述的注解，会保留在class字节码文件中，并被JVM读取到**
     * @Documented：描述注解是否被抽取到api文档中
     * @Inherited：描述注解是否被子类继承

* **在程序中解析注解**

  	1. 获取该类的字节码对象
   	2. 获取注解对象
   	3. 调用注解对象中定义的抽象方法，获取返回值

  ​	